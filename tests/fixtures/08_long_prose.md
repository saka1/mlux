# 型システムと所有権：Rustの設計哲学

## 導入

プログラミング言語の設計において、安全性とパフォーマンスはしばしばトレードオフの関係にある。ガベージコレクションを持つ言語は安全性を提供するが、実行時のオーバーヘッドを伴う。一方、CやC++のような言語は高いパフォーマンスを実現するが、メモリ安全性の保証はプログラマの責任に委ねられる。Rustはこの二項対立を、所有権システムという独自のアプローチによって解決した。コンパイル時の静的解析によってメモリ安全性を保証しつつ、ゼロコスト抽象化の原則に基づいてランタイムオーバーヘッドを排除している。

この設計判断は、Mozillaにおけるブラウザエンジン開発の経験から生まれたものである。大規模なC++コードベースにおけるメモリ関連バグの頻発が、新しい言語の設計動機となった。

## 所有権の三原則

Rustの所有権システムは、以下の三つの規則に基づいている：

1. Rustの各値は「所有者」と呼ばれる変数を持つ
2. ある時点において、所有者は一つだけ存在する
3. 所有者がスコープを抜けると、その値は破棄される

これらの規則は一見単純だが、その含意は深い。例えば、ある関数に値を渡すと所有権が移動（ムーブ）し、元の変数は無効化される。これにより、ダングリングポインタやダブルフリーといった古典的なメモリバグがコンパイル時に防止される。

### 借用と参照

所有権の移動を伴わずに値を利用するために、Rustは「借用」の概念を導入した。借用には二種類ある：

- **不変参照** (`&T`)：複数同時に存在可能。データの読み取りのみ許可される。共有参照とも呼ばれ、並行読み取りの安全性を型レベルで保証する。
- **可変参照** (`&mut T`)：同時に一つだけ存在可能。データの読み書きが許可される。排他参照とも呼ばれ、データ競合をコンパイル時に防止する。

この規則は、読み書きロック（RWLock）のセマンティクスに類似している。複数の読み取りは安全に並行実行できるが、書き込みは排他的に行わなければならない。Rustはこの制約をコンパイル時に強制することで、実行時のロックオーバーヘッドなしにスレッド安全性を実現する。

### ライフタイム

借用には「ライフタイム」と呼ばれる有効期間が関連付けられる。コンパイラはライフタイム解析により、参照が常に有効なデータを指していることを保証する。多くの場合、ライフタイムは省略可能だが、複雑なケースでは明示的なアノテーションが必要になる：

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}
```

この関数シグネチャは、「返り値の参照は、二つの引数のうち短い方のライフタイムと同じ期間だけ有効である」ことを型レベルで表現している。

## トレイトシステム

Rustのトレイトは、Haskellの型クラスに着想を得たアドホック多相の仕組みである。インターフェースの定義と実装を分離し、ジェネリクスと組み合わせることで強力な抽象化を可能にする。

| 概念 | Rust | Haskell | Java | Go |
|------|------|---------|------|----|
| インターフェース定義 | `trait` | `class` | `interface` | `interface` |
| 実装 | `impl Trait for Type` | `instance` | `implements` | 暗黙的 |
| ジェネリック制約 | `T: Trait` | `Class a =>` | `<T extends I>` | 型アサーション |
| 静的ディスパッチ | デフォルト | デフォルト | 不可 | 不可 |
| 動的ディスパッチ | `dyn Trait` | existential | デフォルト | デフォルト |

> Rustのトレイトシステムの特筆すべき点は、孤児規則（orphan rule）によるコヒーレンスの保証である。あるトレイトをある型に実装できるのは、トレイトまたは型のいずれかが自クレートで定義されている場合に限られる。
>
> この制約は一見不便に思えるが、依存関係の異なるクレート間で矛盾する実装が生じることを防ぎ、大規模なエコシステムにおける型の一貫性を保証している。

## エラーハンドリングとの統合

所有権システムとトレイトは、Rustのエラーハンドリング設計にも深く関わっている。`Result<T, E>` 型は所有権の移動によってエラーの処理漏れを防ぎ、`?` 演算子はトレイト `From` による自動変換を活用する。

```rust
use std::fs;
use std::io;
use std::num::ParseIntError;

#[derive(Debug)]
enum AppError {
    Io(io::Error),
    Parse(ParseIntError),
}

impl From<io::Error> for AppError {
    fn from(e: io::Error) -> Self { AppError::Io(e) }
}

impl From<ParseIntError> for AppError {
    fn from(e: ParseIntError) -> Self { AppError::Parse(e) }
}

fn read_and_parse(path: &str) -> Result<i64, AppError> {
    let content = fs::read_to_string(path)?;  // io::Error → AppError
    let number = content.trim().parse::<i64>()?;  // ParseIntError → AppError
    Ok(number)
}
```

このパターンにより、異なるエラー型を持つ複数の操作を、自然な制御フローで合成できる。エラーの伝播は `?` 演算子で簡潔に記述され、型変換はトレイト実装によって自動化される。

---

*本文書は Rust 1.93 時点の言語仕様に基づく。最新の情報は [The Rust Reference](https://doc.rust-lang.org/reference/) を参照されたい。*
