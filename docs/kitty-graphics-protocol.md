# Kitty Graphics Protocol 仕様リファレンス

tmark Phase 4（ターミナル表示）実装のためのプロトコル仕様書。
公式仕様: https://sw.kovidgoyal.net/kitty/graphics-protocol/

## エスケープシーケンス基本構造

全コマンドが APC (Application Programming Command) 形式:

```
\x1b_G<key=value,key=value,...>;<base64ペイロード>\x1b\
```

- `\x1b_G` — APC開始 + グラフィクスコマンド識別子
- `<control data>` — カンマ区切りの `key=value` ペア
- `;` — 制御データとペイロードの区切り
- `<payload>` — base64エンコードされたバイナリデータ
- `\x1b\` — APC終了（ST: String Terminator）

未対応ターミナルは APC を安全に無視する。

---

## パラメータ完全一覧

### 画像送信パラメータ

| パラメータ | 値 | 説明 |
|---|---|---|
| `f` | `24`, `32`, `100` | 画像フォーマット。24=RGB, 32=RGBA(デフォルト), 100=PNG |
| `s` | ピクセル数 | 画像幅（RGB/RGBAでは必須。PNGでは不要） |
| `v` | ピクセル数 | 画像高さ（RGB/RGBAでは必須。PNGでは不要） |
| `o` | `z` | 圧縮方式。`z`=zlib deflate |
| `t` | `d`, `f`, `t`, `s` | 転送方式。d=直接埋め込み, f=ファイル, t=一時ファイル, s=共有メモリ |
| `i` | 1〜4294967295 | 画像ID（クライアント指定。キャッシュ・再表示に使用） |
| `I` | 整数 | 画像番号（ターミナルが自動ID付与。レスポンスで割当IDが返る） |
| `m` | `0`, `1` | チャンクモード。0=最終チャンク, 1=後続チャンクあり |
| `q` | `0`, `1`, `2` | レスポンス制御。0=通常, 1=OK抑制, 2=エラー抑制 |
| `S` | バイト数 | ファイル/共有メモリから読み取るサイズ |
| `O` | バイト数 | ファイル/共有メモリ内のオフセット |

### アクションパラメータ

| パラメータ | 値 | 説明 |
|---|---|---|
| `a` | `T` | **送信+表示**（デフォルト）。画像データを送信し、即座に表示 |
| `a` | `p` | **配置**。`i` で指定した送信済み画像を表示 |
| `a` | `d` | **削除**。`d` パラメータで削除範囲を指定 |
| `a` | `q` | **クエリ**。送信方式の対応確認。画像は保存されない |
| `a` | `f` | **アニメーションフレーム送信** |
| `a` | `a` | **アニメーション制御** |
| `a` | `c` | **フレーム合成** |

### 配置パラメータ

| パラメータ | 値 | 説明 |
|---|---|---|
| `p` | 1〜4294967295 | 配置ID（同一画像の複数配置を識別） |
| `x` | ピクセル | ソース矩形の左端（画像内クロップ開始X） |
| `y` | ピクセル | ソース矩形の上端（画像内クロップ開始Y） |
| `w` | ピクセル | ソース矩形の幅 |
| `h` | ピクセル | ソース矩形の高さ |
| `X` | ピクセル | セル内ピクセルオフセット（水平） |
| `Y` | ピクセル | セル内ピクセルオフセット（垂直） |
| `c` | 列数 | 表示幅（ターミナルセル単位。アスペクト比維持でスケーリング） |
| `r` | 行数 | 表示高さ（ターミナルセル単位。アスペクト比維持でスケーリング） |
| `z` | 整数 | Z-index（後述） |
| `C` | `0`, `1` | カーソル移動制御。0=移動する(デフォルト), 1=移動しない |

### 相対配置パラメータ

| パラメータ | 値 | 説明 |
|---|---|---|
| `P` | 画像ID | 親画像ID（相対配置の基準） |
| `Q` | 配置ID | 親配置ID |
| `H` | セル数 | 水平方向の変位（正=右） |
| `V` | セル数 | 垂直方向の変位（正=下） |

### Unicode プレースホルダパラメータ

| パラメータ | 値 | 説明 |
|---|---|---|
| `U` | `1` | 仮想配置モード有効化 |

### 削除パラメータ (`d`)

| 値 | 削除対象 | 補足 |
|---|---|---|
| `a` / `A` | 画面上の全配置 | 大文字=画像データも解放 |
| `i` / `I` | 指定ID(`i`)の画像 | `p` で特定配置のみ削除可能 |
| `n` / `N` | 指定番号(`I`)の画像 | `p` で特定配置のみ削除可能 |
| `c` / `C` | カーソル位置の配置 | |
| `p` / `P` | 指定セル(`x,y`)の配置 | |
| `q` / `Q` | 指定セル+Z-index(`x,y,z`)の配置 | |
| `r` / `R` | ID範囲(`x`〜`y`)の画像 | |
| `x` / `X` | 指定列(`x`)と交差する配置 | |
| `y` / `Y` | 指定行(`y`)と交差する配置 | |
| `z` / `Z` | 指定Z-index(`z`)の配置 | |
| `f` / `F` | アニメーションフレーム | |

**小文字**: 配置のみ削除（画像データはキャッシュに残る。`a=p` で再表示可能）
**大文字**: 配置+画像データを削除（再表示には再送信が必要）

---

## 転送方式の詳細

### `t=d` — 直接埋め込み（Direct）

base64エンコードしたデータをエスケープシーケンス内に直接埋め込む。
リモート接続（SSH等）ではこれが唯一の選択肢。

### `t=f` — ファイル参照

ペイロードにファイルパスをbase64エンコードして指定。
ターミナルがシンボリックリンクを辿って読み取る。
デバイスファイル・ソケット・`/proc`・`/sys`・`/dev` は拒否される。

### `t=t` — 一時ファイル

`t=f` と同様だが、ターミナルが読み取り後に自動削除する。
パスが標準一時ディレクトリ内にあり、パスに `tty-graphics-protocol` を含む必要がある。

### `t=s` — 共有メモリ

POSIX: 共有メモリオブジェクト名を指定。ターミナルが読み取り後に `shm_unlink` で解放。
Windows: 名前付きメモリ。読み取り後にクローズ。

---

## チャンク転送の詳細

大きな画像は複数チャンクに分割して送信する必要がある。

### ルール

1. 各チャンクの base64 ペイロードは最大 **4096バイト**
2. 最終チャンク以外は **4の倍数バイト** でなければならない（base64パディング）
3. 最初のチャンクのみ全パラメータを含む
4. 2番目以降のチャンクは `m` キーのみ必須（オプションで `q` も可）
5. アニメーションフレームの場合、2番目以降も `a=f` が必要
6. ターミナルは全チャンク受信+バリデーション完了まで表示しない

### 送信シーケンス例

```
# 3チャンクでのPNG送信（画像ID=1）
\x1b_Gf=100,i=1,a=T,m=1;<chunk1_base64>\x1b\
\x1b_Gm=1;<chunk2_base64>\x1b\
\x1b_Gm=0;<chunk3_base64>\x1b\
```

```
# 画像ID付きで送信（キャッシュ用）、レスポンス抑制
\x1b_Gf=100,i=42,a=T,q=1,m=1;<chunk1>\x1b\
\x1b_Gm=1,q=1;<chunk2>\x1b\
\x1b_Gm=0,q=1;<final_chunk>\x1b\
```

### チャンク分割の実装指針

```
PNG全体のbase64 = base64_encode(png_bytes)
chunks = split_into(base64, 4096)
for (i, chunk) in chunks.enumerate():
    if i == 0:
        send("\x1b_Gf=100,i={id},a=T,m=1;{chunk}\x1b\\")
    elif i < len(chunks) - 1:
        send("\x1b_Gm=1;{chunk}\x1b\\")
    else:
        send("\x1b_Gm=0;{chunk}\x1b\\")
```

---

## ターミナルレスポンス

### 成功時

```
\x1b_Gi=<id>[,I=<number>];OK\x1b\
```

### 失敗時

```
\x1b_Gi=<id>[,I=<number>];<ERRCODE>:<message>\x1b\
```

### エラーコード

| コード | 意味 |
|---|---|
| `ENOENT` | ファイルが見つからない |
| `EINVAL` | 無効なパラメータ（`i` と `I` の同時指定等） |
| `ETOODEEP` | 相対配置のチェーンが深すぎる（最小保証: 8レベル） |
| `ECYCLE` | 相対配置の循環参照 |
| `ENOPARENT` | 相対配置の親が見つからない |
| `ENOSPC` | ストレージクォータ超過 |

### レスポンス制御

- `q=1` — OK レスポンスを抑制（エラーのみ返る）
- `q=2` — エラーレスポンスを抑制（OKのみ返る）
- `q=0` または未指定 — 両方返る

---

## Z-Index レイヤリング

| Z値の範囲 | 描画順 |
|---|---|
| 正の値 | テキストの上に描画 |
| 0 | テキストと同レイヤー |
| 負の値 | テキストの下に描画 |
| < -1,073,741,824 (INT32_MIN/2) | 非デフォルト背景色のセルの下にも描画 |

同一Z-indexの画像が重なる場合、IDが小さい方が下になる。

---

## カーソル移動の挙動

- デフォルト（`C=0`）: 配置後、カーソルが画像の右端+下端まで移動
- `C=1`: 配置後もカーソル位置は変わらない
- 相対配置は `C` の値に関係なくカーソルを移動しない

---

## Unicode プレースホルダシステム

### 概要

画像をUnicode文字 **U+10EEEE**（Private Use Area）に紐付ける方式。
画像がテキストの一部として扱われるため、vim・tmux等のテキスト操作ツールと統合可能。
テキストがスクロールすると画像も自動追従する。

### 仮想配置の作成

```
\x1b_Ga=p,U=1,i=<id>,c=<cols>,r=<rows>\x1b\
```

これ自体は不可視。U+10EEEE を画面に書き込むことで画像が表示される。

### エンコーディング

- **前景色**: 画像ID（256色モード: 8bit, TrueColor: 24bit）
- **結合ダイアクリティカルマーク**: 行番号・列番号のエンコード
  - 1つ目のダイアクリティカル = 行番号
  - 2つ目のダイアクリティカル = 列番号
  - 3つ目のダイアクリティカル = 画像IDの上位バイト

### ダイアクリティカルマークの対応表

| Unicode | 値 |
|---|---|
| U+0305 | 0 |
| U+030D | 1 |
| U+030E | 2 |
| ... | ... |
| U+036F | (最大値) |

### 継承アルゴリズム

左隣のプレースホルダと同じ前景色・下線色を持つ場合、省略されたダイアクリティカルマークは左隣から継承される（行は同一、列はインクリメント）。

---

## 画像ID vs 画像番号

| 概念 | パラメータ | 管理主体 | 用途 |
|---|---|---|---|
| 画像ID | `i` | クライアント | 既知のIDで画像を管理。衝突回避はクライアントの責任 |
| 画像番号 | `I` | ターミナル | ターミナルがユニークIDを自動付与。複数プログラムでの衝突防止 |

`I` を使った場合のレスポンス:
```
\x1b_Gi=99,I=13;OK\x1b\
```
→ 画像番号13に対してID 99が割り当てられた

**`i` と `I` の同時指定は `EINVAL` エラー。**

---

## ストレージクォータ

- ターミナルはストレージ上限を設けている
- クォータ超過時は `ENOSPC` エラー
- 配置されていない画像が優先的に削除される
- 実装依存のため、具体的な上限値は保証されない

---

## アニメーション

### フレーム送信

```
\x1b_Ga=f,i=<id>,x=<x>,y=<y>,s=<w>,v=<h>,z=<gap_ms>,m=1;<frame_data>\x1b\
...
\x1b_Gm=0;<final>\x1b\
```

- `x,y,s,v`: フレーム内の更新矩形（部分更新可能）
- `z`: 次フレームまでの遅延（ミリ秒）。負の値はギャップなし（即座に次フレーム）
- `c`: 合成元フレーム番号（1=ベース画像）
- `Y`: キャンバス背景色（RGBA 32bit）

### アニメーション制御

```
\x1b_Ga=a,i=<id>,s=<state>,v=<loops>\x1b\
```

| `s` | 状態 |
|---|---|
| `1` | 停止 |
| `2` | ロードモード（末尾でフレーム追加待ち） |
| `3` | 通常ループ |

- `v=0`: 無視
- `v=1`: 無限ループ
- `v=n` (n>1): n-1回ループ

### フレーム合成

```
\x1b_Ga=c,i=<id>,r=<src_frame>,c=<dst_frame>,w=<w>,h=<h>,x=<sx>,y=<sy>,X=<dx>,Y=<dy>,C=<mode>\x1b\
```

- `C=0`: アルファブレンド（デフォルト）
- `C=1`: 置換

---

## tmark での利用設計

### 基本方針

1. `height: auto` で Typst コンパイル → 1枚の縦長 PNG を生成
2. PNG 全体を画像ID付きで1回だけ送信（チャンク分割）
3. ビューポート表示は `a=p` + ソース矩形クロップ（`x,y,w,h`）で制御
4. スクロール時は `y` を変更した `a=p` を再送するだけ（画像の再送信不要）

### ターミナルレイアウト

```
 ┌─左マージン(テキスト)──┬──画像領域─────────────┐
 │  1                   │                       │
 │  2                   │  ┌ a=p,i=ID ────────┐ │
 │  3  ▶                │  │ y=scroll_offset  │ │
 │  4                   │  │ w=img_w, h=vp_h  │ │
 │  5                   │  │ c=cols, r=rows   │ │
 │  6                   │  └──────────────────┘ │
 ├──────────────────────┴───────────────────────┤
 │ ステータスバー（通常テキスト）                  │
 └──────────────────────────────────────────────┘
```

- **行番号・マーカー**: ANSI カーソル位置制御 (`\x1b[row;colH`) + 通常テキスト出力
- **画像配置**: カーソルを画像開始位置に移動 → `a=p` で表示
- **表示サイズ制御**: `c` (列数) と `r` (行数) で画像が占有するセル数を制限
- **ステータスバー**: 最終行に通常テキスト出力
- 画像とテキストは別セルに配置されるため干渉しない

### 描画順序

1. 画像送信（`a=t` で送信のみ、1回のみ）+ 初回配置（`a=p`）
2. 行番号描画（`\x1b[row;1H` で各行にカーソル移動、テキスト出力）
3. ステータスバー描画（`\x1b[最終行;1H` でテキスト出力）
4. スクロール時: `a=d,d=i,i=ID` で旧配置削除 → `a=p` で新ビューポート配置

**注意**: `\n` による改行はスクロール発生のリスクがあるため、
絶対座標でのカーソル移動 (`\x1b[row;colH`) を使うこと。

### スクロール時の更新

```
# 初回: 画像送信のみ（a=t 小文字。a=T だと Ghostty でキャッシュされない）
\x1b_Gf=100,i=1,a=t,q=1,m=1;<chunk1>\x1b\
\x1b_Gm=1,q=1;<chunk2>\x1b\
...
\x1b_Gm=0,q=1;<chunkN>\x1b\

# 初回表示: ビューポート上部（a=p で配置）
\x1b[1;7H                              ← カーソルを画像開始位置に移動
\x1b_Ga=p,i=1,x=0,y=0,w=1320,h=800,c=74,r=29\x1b\

# スクロール: 旧配置削除 → 新ビューポート配置（画像の再送信不要）
# ※ \x1b[2J は使わない（Ghostty で画像データごと消える）
\x1b_Ga=d,d=i,i=1,q=1\x1b\            ← 配置のみ削除（データ保持）
\x1b[1;7H
\x1b_Ga=p,i=1,x=0,y=200,w=1320,h=800,c=74,r=29\x1b\
```

### 行境界スナップ

フレームツリーの `TextItem` のY座標を使って、行の途中で切れないビューポートを計算:

1. `PagedDocument` から全 `TextItem` の絶対Y座標を収集
2. Y座標でグループ化 → 行境界のリストを構築
3. スクロール時、最も近い行境界にビューポートのy開始位置をスナップ
4. スナップされた `y` 値を `a=p` のソース矩形に使用

### 将来の改良候補

- **ファーストビュー最適化**: 初回表示を高速化するため、画像を上部から分割送信
  （ビューポート内の部分だけ先に送信し、残りをバックグラウンドで送信）
- **`t=t` 一時ファイル方式**: ローカル接続ではbase64エンコードのオーバーヘッドを回避可能
- **`t=s` 共有メモリ方式**: さらに高速。ただし実装の複雑さとポータビリティのトレードオフ
- **Unicode プレースホルダ**: vim/tmux統合が必要になった場合に検討

### 対応ターミナル

| ターミナル | 対応状況 |
|---|---|
| Kitty | 本家。フル対応 |
| Ghostty | 対応（一部制限あり。下記 Ghostty 固有の注意点を参照） |
| WezTerm | 対応（一部制限あり） |
| iTerm2 | 独自プロトコル（別実装が必要） |

---

## Ghostty 固有の注意点（spike_kitty で実機検証済み）

### `a=t` (小文字) を使うこと — `a=T` ではキャッシュされない

Ghostty では `a=T`（送信+即座表示）で送信した画像が、後続の `a=p` で参照できない（`ENOENT: image not found`）。

```
# NG: Ghostty で a=p 時に ENOENT
\x1b_Ga=T,f=100,i=1,t=d,q=1,m=1;<chunk>\x1b\
...
\x1b_Ga=p,i=1,x=0,y=0,...\x1b\   ← ENOENT

# OK: a=t で送信のみ → a=p で配置
\x1b_Ga=t,f=100,i=1,t=d,q=1,m=1;<chunk>\x1b\
...
\x1b_Ga=p,i=1,x=0,y=0,...\x1b\   ← 成功
```

**原因**: `a=T` はデータ送信と同時に表示するが、Ghostty の実装では画像IDでのキャッシュが行われない模様。`a=t`（送信のみ、表示しない）を使えば画像データがIDに紐付いてキャッシュされ、`a=p` で参照可能になる。

### `\x1b[2J` で画像データが消える

標準的なターミナルクリア `\x1b[2J`（CSI 2 J, Erase in Display）を送ると、Ghostty ではテキストだけでなく **Kitty 画像のキャッシュデータごと破棄** される。

```
# NG: \x1b[2J 後に a=p → ENOENT
\x1b_Ga=t,f=100,i=1,...\x1b\   ← 送信OK
\x1b_Ga=p,i=1,...\x1b\          ← 初回配置OK
\x1b[2J                          ← 画面クリア → 画像データも消える
\x1b_Ga=p,i=1,...\x1b\          ← ENOENT

# OK: a=d,d=i で配置のみ削除（データ保持）
\x1b_Ga=d,d=i,i=1,q=1\x1b\    ← 配置削除（小文字 i = データ保持）
\x1b_Ga=p,i=1,...\x1b\          ← 再配置OK
```

**対策**: スクロール等で画面を更新する際は `\x1b[2J` を使わず、Kitty の `a=d,d=i,i=ID` で配置のみ削除してから `a=p` で再配置する。ステータスバー等のテキスト更新はカーソル移動+上書きで対応する。

### 検証済みスクロール手順

```
1. a=t で PNG をチャンク送信（1回のみ）
2. a=p で初回ビューポート配置
3. スクロール時:
   a. a=d,d=i,i=ID,q=1  — 旧配置を削除（データ保持）
   b. a=p,i=ID,y=新offset — 新ビューポートを配置
   → 画像の再送信は不要
```
| 他 | APC を安全に無視するため、画像なしで動作は継続可能 |
